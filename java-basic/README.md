# Inflearn's Roadmap: PRACTICAL JAVA of KIMYOUNGHAN (2/7)

# BASIC COURSE

## 기본형 vs 참조형

* 기본형(Primitive Type): int, long, double, boolean차람 변수에 사용할 값을 직접 넣을 수 잇는 데이터 타입을 기본형이라 한다.
* 참조형(Reference Type): 클래스 객체나 배열 변수와 같이 데이터에 접근하기 위한 참조를 저장하는 데이터 타입을 참조형이라 한다. 참조형은 객체 또는 배열에 사용된다.

기본형 변수는 변수를 직접 호출해 값을 사용할 수 있다.  
참조형 변수는 값을 사용하기 위해 참조값을 통해 해당 주소로 이용하여야 한다.(값에 접근하기 위해 클래스 변수에 .을 찍어 접근한다.)

> 사실 String도 참조형이나 사용 빈도가 많아 자바에서 특별하게 편의 기능을 제공한다.

## NULL

*참조할 대상이 없다.*

> GC: Garbage Collection
> > NULL 값으로 참조할 수 없는 대상은 접근할 수 없어서 인스턴스를 메모리에서 제거해야한다.  
> > C와 같은 언어는 개발자가 직접 찾아 삭제하고 누락시 메모리 낭비가 발생하고 심한 경우 메모리 부족 오류에 부딪혔다.  
> > 자바는 이런 과정을 자동으로 처리해준다.  
> > 아무도 참조하지 않는 인스턴스가 존재하면 JVM의 GC가 더 이상 사용하지 않는 인스턴스라 판단하고 해당 인스턴스를 메모리에서 제거한다.

### NullPointerExceotion

NULL 값인 객체를 참조하고자 할 때 발생하는 예외
> 예시
```
public class Data {
    int value;
}
```
```java
public class DataMain {

    public static void main {
        Data data = null;
        data.value = 10; // ?
    }
}
```

> Exception in thread "main" java.lang.NullPointerException: Cannot assign field "value" because "data" is null
--- --- ---
## 절차 vs 객채 지향 프로그래밍
### 절차 지향 프로그래밍
* 실행 순서를 중요하게 생각하며 '어떻게'가 중심이 되어 프로그래밍

### 객체 지향 프로그래밍
* 객체간 상호작용을 중요하게 생각하며 '무엇을'이 중심이 되어 프로그래밍

--- --- ---
## 객체의 요소
### 속성과 기능
예를 들어 자동차, 동물, 게임 캐릭터 모두 객체로 분류할 수 있고 단순화해보면 속성과 기능으로 나눌 수 있다.

--- --- ---
## 생성자

### this
사용하고자하는 메서드의 매개변수의 이름이 멤버변수와 이름이 동일할 때  
메서드의 같은 블럭 안에 있는 매개변수가 더 우선시 된다.  
따라서 멤버변수를 참고하고자 할 때 이름 앞에 this.를 붙여주면된다.  
this는 인스턴스 자신의 참조값(멤버변수)을 가르킨다.  

```java
        nameField = nameParamemter
//        this. 생략가능한 경우
//        참조하고자하는 멤버변수의 이름이 매개변수의 이름과 다른 경우 메서드 블럭을 탐색한 후에 자연스럽게 클래스의 멤버변수를 탐색함.
        this.nameField = nameParameter;
//        위와 같이 this.를 붙여 사용하는 코딩 스타일도 있다.
//        위 코딩 스타일의 경우 참조하고자하는 멤버변수를 정확하게 알 수 있다는 장점이 있다.
//        최근 IDE에서 이런 멤버변수와 매개변수에 색상 차이를 두어 구분할 수 있기에 사라지는 추세.
```

### 생성자의 장점
* 중복 호출 제거
```java
// 생성 따로 호출 따로 다소 비효율적인 상황
MemberInit member = new MemberInit();
member.initMember("user1", 15, 90);

// 생성 및 호출을 동시에 진행하는 생성자의 큰 장점
MemberConstruct member = new MemberConstruct("user1", 15, 90);
```
* 생성자 매개변수로 제약조건 설정
    + 입력 필수값을 받을 수 있다.

> 좋은 프로그램은 무한한 자유도가 주어지는 프로개름이 아니라 적절한 제약이 있는 프로그램

### 기본 생성자
* 매개변수가 없는 생성자
* 클래스 내에 생성자가 존재하지 않을 경우 기본 생성자가 자동으로 만들어짐
* **생성자가 하나라도 있다면 기본 생성자는 존재하지 않음**

this()는 생성자 블럭 내에서 가장 첫 줄에서만 쓰일 수 있다.

### 접근 제어자

#### private
* 외부 클래스에서 호출하고 제어할 수 없음
* 해당 클래스 내에서만 접근 제어 가능

#### default
* 동일한 패키지 내 외부 클래스에서 호출 가능
> package-private
> > 접근 제어자를 명시하지 않는 경우 default 제어자가 기본으로 설정되나
> > 정확한 명칭은 package-private가 더 적합하다.
> > 편의를 위해 default라고 설정되었다.

#### protected
* 동일한 패키지 혹은 상속 관계의 패키지 내에서 호출 가능

#### public
* 외부 클래스에서 호출하고 제어할 수 있음

### 클래스의 접근 제어자
* 클래스 접근 제어자는 public과 dafault만 사용할 수 있음

#### public
* 파일명과 클래스명이 항상 같아야 함.
* 외부 접근 허용

#### default
* 동일한 패키지 내에서만 사용할 수 있음

### 캡슐화(Encapsulation)
* 객체 지향 프로그래밍의 중요한 개념 중 하나
* 데이터와 해당 데이터를 처리하는 메서드를 하나로 묶어 외부에서의 접근을 제한함
* 주로 속성(데이터)과 기능을 숨기고자 함

--- --- ---

## Section 8, 자바 메모리 구조와 static
### 자바의 메모리 구조
  ####
  + 메서드 영역(Method Area): 프로그램 실행에 필요한 공통 데이터 관리, 프로그램 모든 영역에서 공유
    - 클래스 정보: 클래스의 실행 코드(byte code), 필드, 메서드와 생성자 코드 등 모든 실행 코드가 존재
    - static 영역: static 변수들을 보관
    - 런타임 상수 풀: 프로그램 실행에 필요한 공통 리터럴 상수 보관. 이 외에 프로그램의 효율을 위한 상수들을 관리
    ####
  + 스택 영역(Stack Area): 자바 실행 시, 하나의 실행 스택이 생성. 각 스택 프레임은 지역 변수, 중간 연산 결과, 메서드 호출 정보 등을 포함
    - 스택 프레임: 스택 영역에 쌓이는 네모 박스가 하나의 스택 프레임. 메서ㄷ를 호출할 때 마다 하나의 스택 프레임이 쌓이고, 메서드 종료시 해당 스택 프레임이 제거됨
    ####
  + 힙 영역(Heap Area): 객체(인스턴스)와 배열이 생성되는 영역. GC가 이루어지는 주요 영역이며, 더 이상 참조되지 않는 객체는 GC에 의해 제거됨
  > 스택 영역은 더 정확히, 각 쓰레드 별로 하나의 실행 스택이 생성. 쓰레드 수 만큼 스택 영역이 생성된다.

### 스택과 큐 자료 구조
#### 후입 선출(LIFO, Last In First Out)
나중에 넣은 것이 가장 먼저 나오는 것이 후입 선출, 이런 자료 구조를 '**스택(Stack)**'이라고 한다.
* 자바는 스택 영역을 사용해 메서드 호출과 지역 변수(매개 변수 포함)를 관리
* 메서드를 계속 호출하면 스택 프레임이 쌓임
* 지역변수(매개변수 포함)는 스택 영역에서 관리
* 스택 프레임이 종료되면 지역 변수도 함께 제거
* 스택 프레임이 모두 제거되면 프로그램 종료

#### 선입 선출(FIFO, First In First Out)
가장 먼저 넣은 것이 가장 먼저 나오는 것이 선입 선출, 이런 자려 구조를 '**큐(Queue)**'라고 한다

> 지역 변수는 스택 영역에, 객체(인스턴스)는 힙 영역에 관리되는 것.

### static 변수
* 주로 멤버 변수와 메서드에 사용됨
* 멤버 변수에 static을 붙이면 static 변수, 정적 변수 또는 클래스 변수라 한다.
* 정적 변수는 인스턴스 영역이 아닌 메서드 영역에서 관리한다.

#### 멤버 변수(필드)의 종류
* 인스턴스 변수: static이 붙지 않은 멤버 변수
    + static이 붙지 않은 멤버 변수는 인스턴스를 생성해야 사용할 수 있고, 인스턴스에 소속됨. 띠라서 인스턴스 변수
    + 인스턴스 변수는 인스턴스를 만들 때 마다 새로 만들어짐
####
* 클래스 변수: static이 붙은 멤버 변수
    + 클래스 변수, 정적 변수, static 변수 등으로 부른다.
    + static이 붙은 멤버 변수는 인스턴스와 무관하게 클래스에 바로 접근해서 사용할 수 있고, 클래스 자체에 소속되어 있다. 따라서 클래스 변수
    + 클래스 변수는 자바 프로그램을 시작할 때 딱 1개가 만들어진다. 인스턴스와는 다르게 보통 여러곳에서 공유하는 목적으로 사용

#### 변수와 생명주기
* 지역 변수(매개변수 포함): 지역변수는 스택 영역에 있느 스택 프레임 안에 보관. 메서드가 종료되면 스택 프레임도 재거. 이때 해당 스택 프레임에 포함된 지역 변수도 함께 제거. 따라서 지역 변수는 생존 주기가 짧다.
####
* 인스턴스 변수: 인스턴스에 있는 멤버 변수를 인스턴스 변수라 함. 인스턴스 변수는 힙 영역을 사용한다. 힙 영역은 GC가 발생하기 전까지 생존하기 때문에 보통 변수보다 생존 주기가 길다.
####
* 클래스 변수: 클래스 변수는 메서드 영역의 static 영역에 보관되는 변수이다. 메서드 영역은 프로그램 전체에서 사용하는 공용 공간이다. 클래스 변수는 해당 클래스가 JVM에 로딩되는 순간 생서오딘다 .그리고 JVM이 종료될 때 까지 생명주기가 이어진다. 따라서 가장 긴 생명 주기를 가진다.

--- --- ---

### static 메서드
#### 클래스 메서드
* static을 메서드 앞에 붙여 **정적 메서드** 또는 **클래스 메서드**라 한다. 정적 메서드라는 용어는 static이 정적이라는 의미를 가지고 있기 때문이고, 클래스 메서드는 인스턴스 생성 없이 마치 클래스에 있는 메서드를 바로 호출하는 것처럼 보여지기 때문이다.

#### 인스턴스 메서드
* static이 붙지 않은 메서드는 인스턴스를 생성해야 호출할 수 있다. 이것을 인스턴스 메서드라 한다.

#### 정적 메서드 사용법
* static 메서드는 static만 사용할 수 있다
    + 클래스 내부의 기능을 사용할 때, 정적 메서드는 static이 붙은 정적 메서드나 정적 변수만 사용할 수 있다.
    + 정적 메서드는 인스턴스 변수나, 인스턴스 메서드를 사용할 수 없다.
* 반대로 모든 곳에서 static을 호출할 수 있다.
    + 정적 메서드는 공용 기능이다. 따라서 접근 제어자만 허락한다면 클래스를 통해 모든 곳에서 static을 호출할 수 있다.

#### 멤버 메서드의 종류
* 인스턴스 메서드: static이 붙지 않은 멤버 메서드  
    > static이 붙지 않은 멤버 메서드는 인스턴스를 생성해야 사용할 수 있고, 인스턴스에 소속되어 있다. 따라서 인스턴스 메서드라 한다.
####
* 클래스 메서드: static이 붙은 메서드
    + 클래스 메서드, 정적 메서드, static 메서드 등으로 불림.  

    > static이 붙은 메서드는 인스턴스와 무관하게 클래스에 바로 접근해서 사용할 수 있고, 클래스 자체에 소속되어 있다. 
따라서 클래스 메서드라 한다.

#### main() 메서드는 정적 메서드
* main()은 프로그램의 시작점. 별도의 객체 없이도 main() 메서드가 작동함.

### fianl

#### 상수(Constant)
상수는 변하지 않고 항상 일정한 값을 갖는 수

#### 자바 상수의 특징
* static final 키워드 사용
* 대문자를 사용하고 구분은 _(언더스코어)
    + 일반적인 변수와 상수를 구분하기 위함.
* 필드를 직접 접근해 사용
    + 상수는 기능이 아닌 고정된 값 자체 사용에 의의
    + 값을 변경할 수 없다. 필드에 직접 접근해도 변하는 문제가 발생하지 않는다.

#### final 변수와 참조
* 변수는 크게 기본형 변수와 참조형 변수가 있다.
* 기본형 변수는 10, 20 같은 값을 보관하고, 참조형 변수는 객체의 참조값을 보관함
    + final을 기본형 변수에 사용하면 값을 변경할 수 없음
    + final 참조형 변수는 참조값을 변경할 수 없음

### 상속

#### 상속 관계
상속은 객체 지향 프로그래밍의 핵심 요소 중 하나로, 기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용하게 해줌.
기존 클래스의 속성과 기능을 그대로 물려받고 키워드는 extends 키워드를 사용.
extends 대상은 하나만 선택할 수 있음(단일 상속).

#### 용어 정리
* 부모 클래스(슈퍼 클래스): 상속을 통해 자신의 필드와 메서드를 다른 클래스에 제공하는 클래스
* 자식 클래스(서브 클래스): 부모 클래스로부터 필드와 메서드를 상속받는 클래스

#### 짚고 넘어가기
* 상속 관계의 객체를 생성하면 그 내부에는 부모와 자식이 모두 생성된다.
* 상속 관계의 객체를 호출할 때, 대상 타입을 정해야 한다. 이때 호출자의 타입을 통해 대상 타입을 찾는다.
* 현재 타입에서 기능을 찾지 못하면 상위 부모 타입으로 기능을 찾아서 실행한다. 기능을 찾지 못하면 컴파일 오류가 발생한다.

#### 상속과 메서드 오버라이딩
* 부모로부터 상속 받은 기능을 재정의 하는 것을 메서드 오버라이딩(Overriding)이라고 한다.

#### 오버로딩(Overloading) vs 오버라이딩(Overriding)
* 메서드 오버로딩: 메서드 이름이 같고 파라미터가 다른 메서드를 여러개 정의하는 것.
  + 동일한 이름의 메서드를 여러 개 정의함.
* 메서드 오버라이딩: 하위 클래스에서 상속 받을 상위 클래스의 메서드를 재정의하는 것.

#### 오버라이딩 조건
* 메서드 이름이 같아야 함.
* 파라미터, 순서, 개수가 같아야 함.
* 반환 타입이 같아야 함.
* 오버라이딩 메서드의 접근자가 상위 클래스 메서드 접근자보다 제한적일 수 없음.
* 상위 클래스의 메서드보다 더 많은 체크 예외를 throws로 선언할 수 없다.
* static, final, private 제어자 메서드는 오버라이딩 할 수 없다.  
  + static은 클래스 레벨에서 작동해 오버라이딩 의미가 없다.  
  + final은 메서드 재정의를 금지  
  + private 메서드는 해당 클래스에서만 접근할 수 있음.  
* 셍성자는 오버라이딩 할 수 없다.

#### 상속과 접근 제어
* '+' public
* '#' protected
* '~' default
* '-' private

#### super - 부모 참조
상위 하위 필드명이 같거나 오버라이딩된 메서드는 하위클래스에서 호출할 수 없다. 이때 **super** 키워드를 사용하여 상위 클래스를 참조할 수 있다.
* super: 상위 클래스
* this: 본인 클래스

### super - 생성자
**상속 관계를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 한다.**


